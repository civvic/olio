"""basic helpers"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_basic.ipynb.

# %% ../nbs/00_basic.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['AD', 'is_listy', 'is_listy_type', 'flatten', 'shorten', 'pops_', 'pops_values_', 'gets', 'update_']

# %% ../nbs/00_basic.ipynb
import pprint
from inspect import Parameter
from typing import Hashable
from typing import Iterable
from typing import Mapping
from typing import Self
from typing import TypeVar

import fastcore.all as FC


# %% ../nbs/00_basic.ipynb
_VT = TypeVar('_VT')
# from `fastcore` + generics
class AD(dict[str, _VT]):
    "`dict` subclass that also provides access to keys as attrs"
    def __getattr__(self, k:str) -> _VT: return self[k] if k in self else FC.stop(AttributeError(k))  # type: ignore
    def __setattr__(self, k, v:_VT): (self.__setitem__, super().__setattr__)[k[0]=='_'](k,v)
    def __dir__(self) -> Iterable[str]: return super().__dir__() + list(self.keys())  # type: ignore
    def _repr_markdown_(self): return f'```json\n{pprint.pformat(self, indent=2)}\n```'
    def copy(self) -> Self: return type(self)(**self)


# %% ../nbs/00_basic.ipynb
def is_listy(x):
    return isinstance(x, Iterable) and not isinstance(x, (bytes, str))

def is_listy_type(x):
    return issubclass(x, Iterable) and not issubclass(x, (bytes, str))


# %% ../nbs/00_basic.ipynb
def flatten(o):
    "Concatenate all collections and items as a generator"
    for item in o:
        if not is_listy(item): yield item; continue
        try: yield from flatten(item)
        except TypeError: yield item


# %% ../nbs/00_basic.ipynb
def shorten(x, mode='l', limit=40, trunc='â€¦', empty='') -> str:
    s = str(x)
    if len(s) > limit:
        # s = f'{s[:limit//2]} ... {s[:-limit//2]}'
        # s = s[:limit] + '..' * (len(s) > limit)
        # s = (
        #         f'...{s[sl1:sl2]}'
        #         if mode == 'l' else 
        #         f's[sl1:sl2]...'
        #     )
        # sl1, sl2, l, r = (-limit, None, trunc, empty) if mode == 'l' else (None, limit, empty, trunc)
        # s = f'{l}{s[sl1:sl2]}{r}'
        l, m, r = (
            (empty, trunc, s[-limit:]) if mode == 'l' else 
            (s[:limit], trunc, empty) if mode == 'r' else 
            (s[:(limit//2)-1], f" {trunc} ", s[-(limit//2-1):])
        )
        s = f'{l}{m}{r}'
    return s


# %% ../nbs/00_basic.ipynb
def pops_(d: dict, *ks: Hashable) -> dict:
    "Pop existing `ks` items from `d` in-place into a dictionary."
    return {k:d.pop(k) for k in ks if k in d}


# %% ../nbs/00_basic.ipynb
def pops_values_(d: dict, *ks: Hashable) -> tuple:
    "Pop existing `ks` items from `d` in-place into a tuple of values or `Parameter.empty` for missing keys."
    return tuple(d.pop(k, Parameter.empty) for k in ks)


# %% ../nbs/00_basic.ipynb
def gets(d: Mapping, *ks: Hashable):
    "Fetches `ks` values, or `Parameter.empty` for missing keys, from `d` into a tuple."
    return tuple(d.get(k, Parameter.empty) for k in ks)  # type: ignore


# %% ../nbs/00_basic.ipynb
def update_(d:dict|None=None, /, empty_value=None, **kwargs):
    "Update `d` in-place with `kwargs` whose values aren't `empty_value`"
    d = d if d is not None else {}
    for k, v in kwargs.items():
        if v is not empty_value: d[k] = v
    return d

