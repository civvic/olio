"""basic helpers"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_basic.ipynb.

# %% ../nbs/00_basic.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['AD', 'is_listy', 'is_listy_type', 'flatten', 'shorten']

# %% ../nbs/00_basic.ipynb
import pprint
from typing import Iterable
from typing import Self
from typing import TypeVar

import fastcore.all as FC


# %% ../nbs/00_basic.ipynb
_VT = TypeVar('_VT')
# from `fastcore` + generics
class AD(dict[str, _VT]):
    "`dict` subclass that also provides access to keys as attrs"
    def __getattr__(self, k:str) -> _VT: return self[k] if k in self else FC.stop(AttributeError(k))  # type: ignore
    def __setattr__(self, k, v:_VT): (self.__setitem__, super().__setattr__)[k[0]=='_'](k,v)
    def __dir__(self) -> Iterable[str]: return super().__dir__() + list(self.keys())  # type: ignore
    def _repr_markdown_(self): return f'```json\n{pprint.pformat(self, indent=2)}\n```'
    def copy(self) -> Self: return type(self)(**self)


# %% ../nbs/00_basic.ipynb
def is_listy(x):
    return isinstance(x, Iterable) and not isinstance(x, (bytes, str))

def is_listy_type(x):
    return issubclass(x, Iterable) and not issubclass(x, (bytes, str))


# %% ../nbs/00_basic.ipynb
def flatten(o):
    "Concatenate all collections and items as a generator"
    for item in o:
        if not is_listy(item): yield item; continue
        try: yield from flatten(item)
        except TypeError: yield item


# %% ../nbs/00_basic.ipynb
def shorten(x, mode='l', limit=40, trunc='â€¦', empty='') -> str:
    s = str(x)
    if len(s) > limit:
        # s = f'{s[:limit//2]} ... {s[:-limit//2]}'
        # s = s[:limit] + '..' * (len(s) > limit)
        # s = (
        #         f'...{s[sl1:sl2]}'
        #         if mode == 'l' else 
        #         f's[sl1:sl2]...'
        #     )
        # sl1, sl2, l, r = (-limit, None, trunc, empty) if mode == 'l' else (None, limit, empty, trunc)
        # s = f'{l}{s[sl1:sl2]}{r}'
        l, m, r = (
            (empty, trunc, s[-limit:]) if mode == 'l' else 
            (s[:limit], trunc, empty) if mode == 'r' else 
            (s[:(limit//2)-1], f" {trunc} ", s[-(limit//2-1):])
        )
        s = f'{l}{m}{r}'
    return s

