"""Base and helpers for classes that can be augmented with callbacks"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_callback.ipynb.

# %% ../nbs/10_callback.ipynb 1
from __future__ import annotations

# %% auto 0
__all__ = ['EmptyT', 'NoTotalT', 'Callback', 'run_cbs', 'PassCB', 'HasCallbacks', 'with_cbs', 'CollectionTracker']

# %% ../nbs/10_callback.ipynb
import time
from contextlib import contextmanager
from functools import partial
from inspect import Parameter
from operator import attrgetter
from typing import Any
from typing import Iterable
from typing import Sequence
from typing import Type
from typing import TypeAlias

import fastcore.all as FC


# %% ../nbs/10_callback.ipynb
from .basic import AD
from .project import setup_console


# %% ../nbs/10_callback.ipynb
class Callback(): 
    order = 0
    cbs: list[Callback]  # if present, run callbacks in the list after running this callback


# %% ../nbs/10_callback.ipynb
def run_cbs(cbs: Sequence[Callback] | FC.L, method_nm:str, caller=None):
    "Run `method_nm(caller)` of each callback in `cbs` in order."
    for cb in sorted(cbs, key=attrgetter('order')):
        if method := getattr(cb, method_nm, None): method(caller)
        if nested := getattr(cb, 'cbs', None): run_cbs(nested, method_nm, caller)


# %% ../nbs/10_callback.ipynb
class PassCB(Callback):
    def noop(self, *args, **kwargs): pass
    def __getattr__(self, name): return self.noop


# %% ../nbs/10_callback.ipynb
class HasCallbacks:
    "Base for classes that can be augmented with callbacks."
    cbs: list[Callback]
    cbs_names: tuple[str,...] = ()  # this callbacks becomes self methods if a subclass overrides them

    def __new__(cls, *args, **kwargs):
        self = super().__new__(cls)
        self.cbs = []#PassCB()]
        return self

    def __init__(self, cbs:Sequence[Callback]=()): self.cbs = list(cbs)

    def with_cbs(self, cbs:Sequence[Callback], extend=False):
        if extend: self.cbs.extend(cbs)
        else: self.cbs = list(cbs)
        return self
    
    @contextmanager
    def this_cbs(self, cbs:Sequence[Callback]):
        "Use temporary `cbs` in `with` block."
        for cb in cbs: self.cbs.append(cb)
        try:
            yield        
        finally:
            for cb in cbs: self.cbs.remove(cb)

    def __getattr__(self, name):
        "Run `name` as a callback if it's in `self.cbs_names`."
        if name in self.cbs_names: return partial(self.callback, name)
        raise AttributeError(name)

    def callback(self, method_nm): run_cbs(self.cbs, method_nm, self)


# %% ../nbs/10_callback.ipynb
class with_cbs:
    def __init__(self, nm:str|None=None): self.nm = nm
    def __call__(self, f):
        def _f(o, *args, **kwargs):
            nm = self.nm or f.__name__
            try:
                o.callback(f'before_{nm}')
                f(o, *args, **kwargs)
                o.callback(f'after_{nm}')
            except globals()[f'Cancel{nm.title()}Exception']: pass
            finally: o.callback(f'cleanup_{nm}')
        return _f

# %% ../nbs/10_callback.ipynb
_EMPTY: TypeAlias = Parameter.empty
EmptyT = Type[_EMPTY]
NoTotalT: TypeAlias = None

# %% ../nbs/10_callback.ipynb
class CollectionTracker(HasCallbacks):
    "Base for tracking iteration state over a collection, extensible via subclassing."
    idx: int|None = None
    start_time: float|None = None
    elapsed_time: float|None = None

    cbs_names = ('on_start', 'on_stop', 'before_iter', 'after_iter', 'on_update', 'on_interrupt')

    @property
    def state(self):
        st = AD(idx=self.idx, total=self.total, 
            progress=self.progress, elapsed_time=self.elapsed_time)
        if self.interrupted: st.interrupted = True
        return st

    @property
    def progress(self):
        if self.total is not None and self.idx is not None and self.total:
            return min(1.0, round((self.idx+1) / float(self.total), 4))
        return None

    def update(self, idx:int|None=None):
        if self.idx is None: self.idx = self._start(idx or 0)
        if not self.active or (self.total is not None and self.idx >= self.total): return
        self.elapsed_time = time.time() - self.start_time  # type: ignore
        self.on_update()
        if idx is None: idx = self.idx + 1
        if self.total is not None and idx >= self.total:
            self.after_iter()
            self._stop()
        self.idx = idx
    
    def _start(self, idx:int):
        self.active = True
        self.start_time = time.time()
        self.on_start()
        self.before_iter()
        self.idx = idx
        return idx

    def _stop(self):
        if self.active:
            self.active = False
            self.on_stop()

    def __iter__(self):
        # if self.total != 0: self._setup(0)
        self._start(0)
        try:
            for i, o in enumerate(self.source):
                if self.total is not None and i >= self.total: break
                yield o
                self.update()
            if self.total is None:
                self.total = self.idx
                self.update(self.total)
        except Exception as e:
            self.interrupted = True
            self.on_interrupt()
            raise e
        finally: self._stop()

    def __init__(self, source:Iterable[Any], total:int|NoTotalT|Type[_EMPTY]=_EMPTY, **kwargs):
        super().__init__(**kwargs)
        self.source = source
        if total is _EMPTY: 
            try: total = len(source)  # type: ignore
            except: total = None
        self.total: int|None = total  # type: ignore
        self.interrupted = False
        self.active = False
