# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/20_widgets.ipynb.

# %% ../nbs/20_widgets.ipynb 1
from __future__ import annotations


# %% auto 0
__all__ = ['cleanupwidgets', 'wait_for_change', 'yield_for_change']

# %% ../nbs/20_widgets.ipynb
import asyncio
import time
from functools import wraps

import ipywidgets as W


# %% ../nbs/20_widgets.ipynb
from .basic import _get_globals


# %% ../nbs/20_widgets.ipynb
def cleanupwidgets(*ws, mod: str|None=None, clear=True):
    from IPython.display import clear_output
    glb = _get_globals(mod or __name__)
    for w in ws:
        _w = glb.get(w) if isinstance(w, str) else w
        if _w:
            try: _w.close()  # type: ignore
            except: pass
    if clear: clear_output(wait=False)

# %% ../nbs/20_widgets.ipynb
def wait_for_change(widget:W.Widget, value:str):
    future = asyncio.Future()
    def getvalue(change):
        future.set_result(change.new)
        widget.unobserve(getvalue, value)
    widget.observe(getvalue, value)
    return future

# %% ../nbs/20_widgets.ipynb
def yield_for_change(widget, attribute):
    """Pause a generator to wait for a widget change event.
        
    This is a decorator for a generator function which pauses the generator on yield
    until the given widget attribute changes. The new value of the attribute is
    sent to the generator and is the value of the yield.
    """
    def f(iterator):
        @wraps(iterator)
        def inner():
            i = iterator()
            def next_i(change):
                try: i.send(change.new)
                except StopIteration as e: widget.unobserve(next_i, attribute)
            widget.observe(next_i, attribute)
            # start the generator
            next(i)
        return inner
    return f
